CCS PCH C Compiler, Version 4.124, 5967               17-jan-13 11:46

               Filename: C:\Users\cuki\Eletronica\Projetos\Encoder\encoder.lst

               ROM used: 620 bytes (2%)
                         Largest free fragment is 32148
               RAM used: 7 (0%) at main() level
                         16 (1%) worst case
               Stack:    3 locations

*
0000:  GOTO   01D0
.................... #include <18F452.h> 
.................... //////// Standard Header file for the PIC18F452 device //////////////// 
.................... #device PIC18F452 
.................... #list 
....................  
....................  
.................... #fuses	H4,NOOSCSEN,NOPUT,NOBROWNOUT,NOWDT,NOSTVREN 
.................... #fuses	NODEBUG,NOPROTECT,NOCPB,NOCPD,NOWRT,NOLVP 
.................... #fuses	NOWRTD,NOEBTR,NOEBTRB,NOWRTC,NOWRTB 
....................  
.................... #use delay(clock=32MHz, crystal=8MHz) 
*
0016:  CLRF   FEA
0018:  MOVLW  0D
001A:  MOVWF  FE9
001C:  MOVF   FEF,W
001E:  BZ    003A
0020:  MOVLW  0A
0022:  MOVWF  01
0024:  CLRF   00
0026:  DECFSZ 00,F
0028:  BRA    0026
002A:  DECFSZ 01,F
002C:  BRA    0024
002E:  MOVLW  5F
0030:  MOVWF  00
0032:  DECFSZ 00,F
0034:  BRA    0032
0036:  DECFSZ FEF,F
0038:  BRA    0020
003A:  RETURN 0
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7) 
.................... #use i2c(master, scl=pin_c3, sda=pin_c4, fast=150000, force_hw) 
*
005E:  BCF    FC6.7
0060:  BCF    F9E.3
0062:  MOVFF  0D,FC9
0066:  MOVLW  02
0068:  BTFSC  FC6.7
006A:  BRA    0076
006C:  BTFSS  F9E.3
006E:  BRA    006C
0070:  MOVLW  00
0072:  BTFSC  FC5.6
0074:  MOVLW  01
0076:  MOVWF  01
0078:  RETURN 0
*
00A8:  BCF    FC6.6
00AA:  BSF    FC5.3
00AC:  BTFSC  FC5.3
00AE:  BRA    00AC
00B0:  BTFSC  00.0
00B2:  BCF    FC5.5
00B4:  BTFSS  00.0
00B6:  BSF    FC5.5
00B8:  BSF    FC5.4
00BA:  BTFSC  FC5.4
00BC:  BRA    00BA
00BE:  MOVFF  FC9,01
00C2:  RETURN 0
....................  
.................... #include"AM4096.h" 
.................... /* 
....................  * AM4096.h 
....................  * 
....................  *  Created on: 17/01/2013 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #ifndef AM4096_H_ 
.................... #define AM4096_H_ 
....................  
.................... #define AM4096ADDR 0 
.................... #define err 0xFFFF 
.................... #define REG51  51 
....................  
.................... short handshake(int addr) { 
*
007A:  BSF    0C.0
.................... 	short ack = 1; 
.................... 	i2c_start(); 
007C:  BSF    FC5.0
007E:  BTFSC  FC5.0
0080:  BRA    007E
.................... 	ack = i2c_write(addr); 
0082:  MOVFF  0B,0D
0086:  RCALL  005E
0088:  MOVF   01,W
008A:  BCF    0C.0
008C:  BTFSC  01.0
008E:  BSF    0C.0
.................... 	i2c_stop(); 
0090:  BSF    FC5.2
0092:  BTFSC  FC5.2
0094:  BRA    0092
.................... 	delay_ms(10); 
0096:  MOVLW  0A
0098:  MOVWF  0D
009A:  RCALL  0016
.................... 	return ack; 
009C:  MOVLW  00
009E:  BTFSC  0C.0
00A0:  MOVLW  01
00A2:  MOVWF  01
.................... } 
00A4:  GOTO   00CE (RETURN)
....................  
.................... long write_i2c(int addr, int mem, int data) { 
.................... 	if (handshake(addr)) 
.................... 		return err; 
.................... 	else { 
.................... 		i2c_start(); 
.................... 		i2c_write(addr); 
.................... 		i2c_write(mem); 
.................... 		i2c_start(); 
.................... 		i2c_write(addr + 1); 
.................... 		i2c_write(data); 
.................... 		i2c_stop(); 
.................... 		return 0; 
.................... 	} 
.................... } 
....................  
.................... long read_i2c(int addr, int mem) { 
*
00C4:  CLRF   09
00C6:  CLRF   0A
.................... 	int msb = 0, lsb = 0; 
.................... 	if (handshake(addr)) 
00C8:  MOVFF  07,0B
00CC:  BRA    007A
00CE:  MOVF   01,F
00D0:  BZ    00DC
.................... 		return err; 
00D2:  MOVLW  FF
00D4:  MOVWF  01
00D6:  MOVWF  02
00D8:  BRA    0126
.................... 	else { 
00DA:  BRA    0126
.................... 		i2c_start(); 
00DC:  BSF    FC5.0
00DE:  BTFSC  FC5.0
00E0:  BRA    00DE
.................... 		i2c_write(addr); 
00E2:  MOVFF  07,0D
00E6:  RCALL  005E
.................... 		i2c_write(mem); 
00E8:  MOVFF  08,0D
00EC:  RCALL  005E
.................... 		i2c_start(); 
00EE:  BSF    FC5.1
00F0:  BTFSC  FC5.1
00F2:  BRA    00F0
.................... 		i2c_write(addr + 1); 
00F4:  MOVLW  01
00F6:  ADDWF  07,W
00F8:  MOVWF  0B
00FA:  MOVWF  0D
00FC:  RCALL  005E
.................... 		msb = i2c_read(1); 
00FE:  MOVLW  01
0100:  MOVWF  00
0102:  RCALL  00A8
0104:  MOVFF  01,09
.................... 		lsb = i2c_read(1); 
0108:  MOVLW  01
010A:  MOVWF  00
010C:  RCALL  00A8
010E:  MOVFF  01,0A
.................... 		i2c_stop(); 
0112:  BSF    FC5.2
0114:  BTFSC  FC5.2
0116:  BRA    0114
.................... 		return make16(msb, lsb); 
0118:  MOVFF  09,03
011C:  MOVFF  0A,01
0120:  MOVFF  09,02
0124:  BRA    0126
.................... 	} 
.................... } 
0126:  GOTO   0222 (RETURN)
....................  
.................... #endif /* AM4096_H_ */ 
....................  
....................  
.................... static long leitura; 
....................  
.................... int main(void) { 
*
01D0:  CLRF   FF8
01D2:  BCF    FD0.7
01D4:  CLRF   FEA
01D6:  CLRF   FE9
01D8:  MOVLW  33
01DA:  MOVWF  FAF
01DC:  MOVLW  A2
01DE:  MOVWF  FAC
01E0:  MOVLW  90
01E2:  MOVWF  FAB
01E4:  BSF    F94.3
01E6:  BSF    F94.4
01E8:  MOVLW  35
01EA:  MOVWF  FC8
01EC:  MOVLW  28
01EE:  MOVWF  FC6
01F0:  BSF    FC7.7
01F2:  BCF    FC7.6
01F4:  BSF    FC1.0
01F6:  BSF    FC1.1
01F8:  BSF    FC1.2
01FA:  BCF    FC1.3
01FC:  CLRF   04
01FE:  CLRF   05
....................  
.................... 	delay_ms(500); 
0200:  MOVLW  02
0202:  MOVWF  07
0204:  MOVLW  FA
0206:  MOVWF  0D
0208:  RCALL  0016
020A:  DECFSZ 07,F
020C:  BRA    0204
....................  
.................... 	short ack = 1; 
020E:  BSF    06.0
....................  
.................... 	while (true) { 
.................... 		printf("\fEnviando 0"); 
0210:  MOVLW  04
0212:  MOVWF  FF6
0214:  MOVLW  00
0216:  MOVWF  FF7
0218:  RCALL  003C
.................... 		leitura = read_i2c(AM4096ADDR, REG51); 
021A:  CLRF   07
021C:  MOVLW  33
021E:  MOVWF  08
0220:  BRA    00C4
0222:  MOVFF  02,05
0226:  MOVFF  01,04
.................... 		if (leitura != err) 
022A:  INCFSZ 04,W
022C:  BRA    0234
022E:  INCFSZ 05,W
0230:  BRA    0234
0232:  BRA    024C
.................... 			printf("\n%Lu", leitura); 
0234:  MOVLW  0A
0236:  BTFSS  F9E.4
0238:  BRA    0236
023A:  MOVWF  FAD
023C:  MOVLW  10
023E:  MOVWF  FE9
0240:  MOVFF  05,08
0244:  MOVFF  04,07
0248:  BRA    012A
.................... 		else 
024A:  BRA    0256
.................... 			printf("\nErro"); 
024C:  MOVLW  10
024E:  MOVWF  FF6
0250:  MOVLW  00
0252:  MOVWF  FF7
0254:  RCALL  003C
.................... 		delay_ms(3000); 
0256:  MOVLW  0C
0258:  MOVWF  07
025A:  MOVLW  FA
025C:  MOVWF  0D
025E:  RCALL  0016
0260:  DECFSZ 07,F
0262:  BRA    025A
.................... 	} 
0264:  BRA    0210
.................... 	return 0; 
0266:  MOVLW  00
0268:  MOVWF  01
.................... } 
....................  
026A:  SLEEP 

Configuration Fuses:
   Word  1: 2600   H4 NOOSCSEN
   Word  2: 0E0D   NOPUT NOBROWNOUT BORV20 NOWDT WDT128
   Word  3: 0100   CCP2C1
   Word  4: 0080   NOSTVREN NOLVP NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
