CCS PCH C Compiler, Version 4.124, 5967               23-mar-13 11:13

               Filename: E:\Eletronica\Projetos\Encoder\encoder.lst

               ROM used: 1170 bytes (4%)
                         Largest free fragment is 31598
               RAM used: 12 (1%) at main() level
                         21 (1%) worst case
               Stack:    2 locations

*
0000:  GOTO   0370
.................... #include <18F45K20.h> 
.................... //////// Standard Header file for the PIC18F45K20 device //////////////// 
.................... #device PIC18F45K20 
.................... #list 
....................  
....................  
.................... #fuses H4,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(crystal=15MHz, clock=60MHz) 
*
002A:  CLRF   FEA
002C:  MOVLW  0A
002E:  MOVWF  FE9
0030:  MOVF   FEF,W
0032:  BZ    0050
0034:  MOVLW  13
0036:  MOVWF  01
0038:  CLRF   00
003A:  DECFSZ 00,F
003C:  BRA    003A
003E:  DECFSZ 01,F
0040:  BRA    0038
0042:  MOVLW  73
0044:  MOVWF  00
0046:  DECFSZ 00,F
0048:  BRA    0046
004A:  NOP   
004C:  DECFSZ FEF,F
004E:  BRA    0034
0050:  RETURN 0
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7) 
.................... #use spi(MASTER, DI=PIN_C4, DO=PIN_C5, CLK=PIN_C3, MODE=0,  BAUD=1000000, BITS=16, DATA_HOLD=1) 
*
0064:  MOVF   0E,W
0066:  SUBLW  10
0068:  BZ    0074
006A:  MOVWF  0F
006C:  RLCF   0C,F
006E:  RLCF   0D,F
0070:  DECFSZ 0F,F
0072:  BRA    006C
0074:  BSF    F94.4
0076:  BCF    F94.5
0078:  BCF    F94.3
007A:  BCF    F8B.3
007C:  MOVFF  0E,0F
0080:  BTFSS  0D.7
0082:  BCF    F8B.5
0084:  BTFSC  0D.7
0086:  BSF    F8B.5
0088:  RLCF   0C,F
008A:  RLCF   0D,F
008C:  MOVLW  05
008E:  MOVWF  10
0090:  DECFSZ 10,F
0092:  BRA    0090
0094:  BSF    F8B.3
0096:  NOP   
0098:  RLCF   01,F
009A:  RLCF   02,F
009C:  BTFSS  F82.4
009E:  BCF    01.0
00A0:  BTFSC  F82.4
00A2:  BSF    01.0
00A4:  BCF    F8B.3
00A6:  DECFSZ 0F,F
00A8:  BRA    0080
00AA:  RETURN 0
....................  
.................... #define SLAVE_SELECT PIN_A5 
.................... #include "as5040.h" 
.................... /* 
....................  * as5040.h 
....................  * 
....................  *  Created on: 30/03/2012 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #ifndef AS5040_H_ 
.................... #define AS5040_H_ 
....................  
.................... #define clockwise 0x0000 
.................... #define couter_clockwise 0x8000 
.................... #define direction_mask 0x8000 
.................... #define zero_mask 0x7FE0 
.................... #define index1 0x0000 
.................... #define index3 0x0010 
.................... #define index_mask 0x0010 
.................... #define quatrature_mode	0x0001 
.................... #define step_direction_mode 0x0002 
.................... #define brushless_dc_mode	0x0003 
.................... #define mode_mask 0x0003 
.................... #define _10_bit_resolution 0x0000 
.................... #define _9_bit_resolution 0x0004 
.................... #define _8_bit_resolution 0x0008 
.................... #define _7_bit_resolution 0x000C 
.................... #define resolution_mask	0x000C 
.................... #define DO_PIN PIN_C5 
.................... #define DI_PIN PIN_C4 
.................... #define CLK_PIN PIN_C3 
.................... #ifndef SLAVE_SELECT 
.................... #define SLAVE_SELECT PIN_A5 
.................... #endif 
....................  
.................... static long setup; 
....................  
.................... void write_encoder(long data) { 
....................  
.................... 	register int aux = 0; 
.................... 	register int cont = 0; 
....................  
.................... 	output_high(DO_PIN); 
.................... 	output_low(CLK_PIN); 
.................... 	delay_us(10); 
.................... 	output_high(SLAVE_SELECT); 
.................... 	spi_xfer(data); 
.................... 	output_low(CLK_PIN); 
.................... 	output_low(DO_PIN); 
.................... 	delay_us(2); 
.................... 	for (cont = 0; cont < 16; ++cont) { 
.................... 		output_high(DO_PIN); 
.................... 		delay_us(1); 
.................... 		output_high(CLK_PIN); 
.................... 		delay_us(2); 
.................... 		output_low(CLK_PIN); 
.................... 		delay_us(1); 
.................... 		output_low(DO_PIN); 
.................... 	} 
.................... 	output_low(SLAVE_SELECT); 
.................... } 
....................  
.................... void setup_encoder(long new_setup, int zero_mark) { 
.................... 	if (new_setup & direction_mask) { 
00AC:  ANDLW  00
00AE:  MOVWF  00
00B0:  MOVF   0A,W
00B2:  ANDLW  80
00B4:  MOVWF  03
00B6:  MOVF   00,W
00B8:  IORWF  03,W
00BA:  BZ    00BE
.................... 		setup |= direction_mask; 
00BC:  BSF    05.7
.................... 	} 
.................... 	if (new_setup & index_mask) { 
00BE:  MOVF   09,W
00C0:  ANDLW  10
00C2:  MOVWF  00
00C4:  CLRF   03
00C6:  MOVF   00,W
00C8:  IORWF  03,W
00CA:  BZ    00CE
.................... 		setup |= index_mask; 
00CC:  BSF    04.4
.................... 	} 
.................... 	if (new_setup & mode_mask) { 
00CE:  MOVF   09,W
00D0:  ANDLW  03
00D2:  MOVWF  00
00D4:  CLRF   03
00D6:  MOVF   00,W
00D8:  IORWF  03,W
00DA:  BZ    0114
.................... 		switch (new_setup & mode_mask) { 
00DC:  MOVF   09,W
00DE:  ANDLW  03
00E0:  MOVWF  00
00E2:  CLRF   03
00E4:  MOVF   03,W
00E6:  BNZ   00EE
00E8:  MOVLW  01
00EA:  SUBWF  00,W
00EC:  BZ    0104
00EE:  MOVF   03,W
00F0:  BNZ   00F8
00F2:  MOVLW  02
00F4:  SUBWF  00,W
00F6:  BZ    0108
00F8:  MOVF   03,W
00FA:  BNZ   0102
00FC:  MOVLW  03
00FE:  SUBWF  00,W
0100:  BZ    010C
0102:  BRA    0112
.................... 		case quatrature_mode: 
.................... 			setup |= quatrature_mode; 
0104:  BSF    04.0
.................... 			break; 
0106:  BRA    0114
.................... 		case step_direction_mode: 
.................... 			setup |= step_direction_mode; 
0108:  BSF    04.1
.................... 			break; 
010A:  BRA    0114
.................... 		case brushless_dc_mode: 
.................... 			setup |= brushless_dc_mode; 
010C:  MOVLW  03
010E:  IORWF  04,F
.................... 			break; 
0110:  BRA    0114
.................... 		default: 
.................... 			break; 
0112:  BRA    0114
.................... 		} 
.................... 	} 
.................... 	if (new_setup & resolution_mask) { 
0114:  MOVF   09,W
0116:  ANDLW  0C
0118:  MOVWF  00
011A:  CLRF   03
011C:  MOVF   00,W
011E:  IORWF  03,W
0120:  BZ    015A
.................... 		switch (new_setup & resolution_mask) { 
0122:  MOVF   09,W
0124:  ANDLW  0C
0126:  MOVWF  00
0128:  CLRF   03
012A:  MOVF   03,W
012C:  BNZ   0134
012E:  MOVLW  04
0130:  SUBWF  00,W
0132:  BZ    014A
0134:  MOVF   03,W
0136:  BNZ   013E
0138:  MOVLW  08
013A:  SUBWF  00,W
013C:  BZ    014E
013E:  MOVF   03,W
0140:  BNZ   0148
0142:  MOVLW  0C
0144:  SUBWF  00,W
0146:  BZ    0152
0148:  BRA    0158
.................... 		case _9_bit_resolution: 
.................... 			setup |= _9_bit_resolution; 
014A:  BSF    04.2
.................... 			break; 
014C:  BRA    015A
.................... 		case _8_bit_resolution: 
.................... 			setup |= _8_bit_resolution; 
014E:  BSF    04.3
.................... 			break; 
0150:  BRA    015A
.................... 		case _7_bit_resolution: 
.................... 			setup |= _7_bit_resolution; 
0152:  MOVLW  0C
0154:  IORWF  04,F
.................... 			break; 
0156:  BRA    015A
.................... 		default: 
.................... 			break; 
0158:  BRA    015A
.................... 		} 
.................... 	} 
.................... 	if (zero_mark && zero_mark < 1024) { 
015A:  MOVF   0B,F
015C:  BZ    0184
.................... 		setup |= (long) zero_mark << 5; 
015E:  CLRF   0D
0160:  RLCF   0B,W
0162:  MOVWF  02
0164:  RLCF   0D,W
0166:  MOVWF  03
0168:  RLCF   02,F
016A:  RLCF   03,F
016C:  RLCF   02,F
016E:  RLCF   03,F
0170:  RLCF   02,F
0172:  RLCF   03,F
0174:  RLCF   02,F
0176:  RLCF   03,F
0178:  MOVLW  E0
017A:  ANDWF  02,F
017C:  MOVF   02,W
017E:  IORWF  04,F
0180:  MOVF   03,W
0182:  IORWF  05,F
.................... 	} 
.................... 	output_high(DO_PIN); 
0184:  BCF    F94.5
0186:  BSF    F8B.5
.................... 	delay_us(2); 
0188:  MOVLW  09
018A:  MOVWF  00
018C:  DECFSZ 00,F
018E:  BRA    018C
0190:  BRA    0192
.................... 	output_high(SLAVE_SELECT); 
0192:  BCF    F92.5
0194:  BSF    F89.5
.................... 	delay_us(2); 
0196:  MOVLW  09
0198:  MOVWF  00
019A:  DECFSZ 00,F
019C:  BRA    019A
019E:  BRA    01A0
.................... 	spi_xfer(setup); 
01A0:  MOVFF  05,0D
01A4:  MOVFF  04,0C
01A8:  MOVLW  10
01AA:  MOVWF  0E
01AC:  RCALL  0064
.................... } 
01AE:  GOTO   03CE (RETURN)
....................  
.................... void clear_bus(void) { 
.................... 	output_low(SLAVE_SELECT); 
*
0052:  BCF    F92.5
0054:  BCF    F89.5
.................... 	output_low(CLK_PIN); 
0056:  BCF    F94.3
0058:  BCF    F8B.3
.................... 	output_low(DO_PIN); 
005A:  BCF    F94.5
005C:  BCF    F8B.5
.................... 	output_low(DI_PIN); 
005E:  BCF    F94.4
0060:  BCF    F8B.4
.................... } 
0062:  RETURN 0
....................  
.................... #endif /* AS5040_H_ */ 
....................  
....................  
.................... static long leitura; 
.................... static int zero; 
....................  
.................... void main(void) { 
*
0370:  CLRF   FF8
0372:  BCF    FD0.7
0374:  CLRF   FEA
0376:  CLRF   FE9
0378:  BSF    FB8.3
037A:  MOVLW  1A
037C:  MOVWF  FAF
037E:  MOVLW  06
0380:  MOVWF  FB0
0382:  MOVLW  A6
0384:  MOVWF  FAC
0386:  MOVLW  90
0388:  MOVWF  FAB
038A:  BSF    F94.4
038C:  BCF    F94.5
038E:  BCF    F94.3
0390:  BCF    F8B.3
0392:  MOVLW  00
0394:  MOVWF  F7E
0396:  BCF    FC1.4
0398:  BCF    FC1.5
039A:  MOVF   F7F,W
039C:  ANDLW  E0
039E:  MOVWF  F7F
03A0:  BCF    F79.5
03A2:  BCF    F79.4
03A4:  CLRF   F7A
03A6:  CLRF   F7B
03A8:  CLRF   04
03AA:  CLRF   05
03AC:  CLRF   06
03AE:  CLRF   07
03B0:  CLRF   08
.................... 	delay_ms(100); 
03B2:  MOVLW  64
03B4:  MOVWF  0A
03B6:  RCALL  002A
.................... 	zero = 0; 
03B8:  CLRF   08
.................... 	clear_bus(); 
03BA:  RCALL  0052
.................... 	delay_ms(100); 
03BC:  MOVLW  64
03BE:  MOVWF  0A
03C0:  RCALL  002A
.................... 	setup_encoder(clockwise | _7_bit_resolution | step_direction_mode, zero); 
03C2:  CLRF   0A
03C4:  MOVLW  0E
03C6:  MOVWF  09
03C8:  MOVFF  08,0B
03CC:  BRA    00AC
.................... 	clear_bus(); 
03CE:  RCALL  0052
.................... 	printf("\n\rProg: 7 bits zero %d", zero); 
03D0:  MOVLW  04
03D2:  MOVWF  FF6
03D4:  MOVLW  00
03D6:  MOVWF  FF7
03D8:  MOVLW  14
03DA:  MOVWF  0C
03DC:  RCALL  01B2
03DE:  MOVFF  08,0C
03E2:  MOVLW  1F
03E4:  MOVWF  0D
03E6:  RCALL  01FA
.................... 	delay_ms(1000); 
03E8:  MOVLW  04
03EA:  MOVWF  09
03EC:  MOVLW  FA
03EE:  MOVWF  0A
03F0:  RCALL  002A
03F2:  DECFSZ 09,F
03F4:  BRA    03EC
.................... 	while (TRUE) { 
.................... 		output_low(SLAVE_SELECT); 
03F6:  BCF    F92.5
03F8:  BCF    F89.5
.................... 		leitura = spi_xfer(0); 
03FA:  CLRF   0D
03FC:  CLRF   0C
03FE:  MOVLW  10
0400:  MOVWF  0E
0402:  RCALL  0064
0404:  MOVF   01,W
0406:  MOVFF  02,07
040A:  MOVFF  01,06
.................... 		output_high(SLAVE_SELECT); 
040E:  BCF    F92.5
0410:  BSF    F89.5
.................... 		printf(" \n\r%Lu  -  %d", leitura >> 6, (int) (leitura & 0x0006) >> 1); 
0412:  RRCF   07,W
0414:  MOVWF  0A
0416:  RRCF   06,W
0418:  MOVWF  09
041A:  RRCF   0A,F
041C:  RRCF   09,F
041E:  RRCF   0A,F
0420:  RRCF   09,F
0422:  RRCF   0A,F
0424:  RRCF   09,F
0426:  RRCF   0A,F
0428:  RRCF   09,F
042A:  RRCF   0A,F
042C:  RRCF   09,F
042E:  MOVLW  03
0430:  ANDWF  0A,F
0432:  MOVF   06,W
0434:  ANDLW  06
0436:  MOVWF  00
0438:  CLRF   03
043A:  MOVF   00,W
043C:  BCF    FD8.0
043E:  RRCF   00,W
0440:  MOVWF  0B
0442:  MOVLW  20
0444:  BTFSS  F9E.4
0446:  BRA    0444
0448:  MOVWF  FAD
044A:  MOVLW  0A
044C:  BTFSS  F9E.4
044E:  BRA    044C
0450:  MOVWF  FAD
0452:  MOVLW  0D
0454:  BTFSS  F9E.4
0456:  BRA    0454
0458:  MOVWF  FAD
045A:  MOVLW  10
045C:  MOVWF  FE9
045E:  MOVFF  0A,0D
0462:  MOVFF  09,0C
0466:  BRA    02CA
0468:  MOVLW  22
046A:  MOVWF  FF6
046C:  MOVLW  00
046E:  MOVWF  FF7
0470:  MOVLW  05
0472:  MOVWF  0C
0474:  RCALL  01B2
0476:  MOVFF  0B,0C
047A:  MOVLW  1F
047C:  MOVWF  0D
047E:  RCALL  01FA
.................... 		delay_ms(500); 
0480:  MOVLW  02
0482:  MOVWF  09
0484:  MOVLW  FA
0486:  MOVWF  0A
0488:  RCALL  002A
048A:  DECFSZ 09,F
048C:  BRA    0484
.................... 	} 
048E:  BRA    03F6
.................... } 
0490:  SLEEP 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV18 NOWDT WDT32768
   Word  3: 8F00   CCP2C1 PBADEN LPT1OSC HFOFST MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
