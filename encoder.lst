CCS PCH C Compiler, Version 4.124, 5967               25-mar-13 16:10

               Filename: E:\Eletronica\Projetos\Encoder\encoder.lst

               ROM used: 1066 bytes (3%)
                         Largest free fragment is 31702
               RAM used: 12 (1%) at main() level
                         21 (1%) worst case
               Stack:    2 locations

*
0000:  GOTO   0348
.................... #include <18F45K20.h> 
.................... //////// Standard Header file for the PIC18F45K20 device //////////////// 
.................... #device PIC18F45K20 
.................... #list 
....................  
....................  
.................... #fuses H4,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(crystal=15MHz, clock=60MHz) 
*
0010:  CLRF   FEA
0012:  MOVLW  0A
0014:  MOVWF  FE9
0016:  MOVF   FEF,W
0018:  BZ    0036
001A:  MOVLW  13
001C:  MOVWF  01
001E:  CLRF   00
0020:  DECFSZ 00,F
0022:  BRA    0020
0024:  DECFSZ 01,F
0026:  BRA    001E
0028:  MOVLW  73
002A:  MOVWF  00
002C:  DECFSZ 00,F
002E:  BRA    002C
0030:  NOP   
0032:  DECFSZ FEF,F
0034:  BRA    001A
0036:  RETURN 0
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7) 
.................... #use spi(MASTER, DI=PIN_C4, DO=PIN_C5, CLK=PIN_C3, MODE=0,  BAUD=1000000, BITS=16, DATA_HOLD=1) 
0038:  MOVF   0E,W
003A:  SUBLW  10
003C:  BZ    0048
003E:  MOVWF  0F
0040:  RLCF   0C,F
0042:  RLCF   0D,F
0044:  DECFSZ 0F,F
0046:  BRA    0040
0048:  BSF    F94.4
004A:  BCF    F94.5
004C:  BCF    F94.3
004E:  BCF    F8B.3
0050:  MOVFF  0E,0F
0054:  BTFSS  0D.7
0056:  BCF    F8B.5
0058:  BTFSC  0D.7
005A:  BSF    F8B.5
005C:  RLCF   0C,F
005E:  RLCF   0D,F
0060:  MOVLW  05
0062:  MOVWF  10
0064:  DECFSZ 10,F
0066:  BRA    0064
0068:  BSF    F8B.3
006A:  NOP   
006C:  RLCF   01,F
006E:  RLCF   02,F
0070:  BTFSS  F82.4
0072:  BCF    01.0
0074:  BTFSC  F82.4
0076:  BSF    01.0
0078:  BCF    F8B.3
007A:  DECFSZ 0F,F
007C:  BRA    0054
007E:  RETURN 0
....................  
.................... #define SLAVE_SELECT PIN_A5 
.................... #include "as5040.h" 
.................... /* 
....................  * as5040.h 
....................  * 
....................  *  Created on: 30/03/2012 
....................  *      Author: cuki 
....................  */ 
....................  
.................... #ifndef AS5040_H_ 
.................... #define AS5040_H_ 
....................  
.................... #define clockwise 0x0000 
.................... #define couter_clockwise 0x8000 
.................... #define direction_mask 0x8000 
.................... #define zero_mask 0x7FE0 
.................... #define index1 0x0000 
.................... #define index3 0x0010 
.................... #define index_mask 0x0010 
.................... #define quatrature_mode	0x0001 
.................... #define step_direction_mode 0x0002 
.................... #define brushless_dc_mode	0x0003 
.................... #define mode_mask 0x0003 
.................... #define _10_bit_resolution 0x0000 
.................... #define _9_bit_resolution 0x0004 
.................... #define _8_bit_resolution 0x0008 
.................... #define _7_bit_resolution 0x000C 
.................... #define resolution_mask	0x000C 
.................... #define DO_PIN PIN_C5 
.................... #define DI_PIN PIN_C4 
.................... #define CLK_PIN PIN_C3 
.................... #ifndef SLAVE_SELECT 
.................... #define SLAVE_SELECT PIN_A5 
.................... #endif 
....................  
.................... static long setup; 
....................  
.................... void write_encoder(long data) { 
....................  
.................... 	register int aux = 0; 
.................... 	register int cont = 0; 
....................  
.................... 	output_high(DO_PIN); 
.................... 	output_low(CLK_PIN); 
.................... 	delay_us(10); 
.................... 	output_high(SLAVE_SELECT); 
.................... 	spi_xfer(data); 
.................... 	output_low(CLK_PIN); 
.................... 	output_low(DO_PIN); 
.................... 	delay_us(2); 
.................... 	for (cont = 0; cont < 16; ++cont) { 
.................... 		output_high(DO_PIN); 
.................... 		delay_us(1); 
.................... 		output_high(CLK_PIN); 
.................... 		delay_us(2); 
.................... 		output_low(CLK_PIN); 
.................... 		delay_us(1); 
.................... 		output_low(DO_PIN); 
.................... 	} 
.................... 	output_low(SLAVE_SELECT); 
.................... } 
....................  
.................... void setup_encoder(long new_setup, int zero_mark) { 
.................... 	if (new_setup & direction_mask) { 
0080:  ANDLW  00
0082:  MOVWF  00
0084:  MOVF   0A,W
0086:  ANDLW  80
0088:  MOVWF  03
008A:  MOVF   00,W
008C:  IORWF  03,W
008E:  BZ    0092
.................... 		setup |= direction_mask; 
0090:  BSF    05.7
.................... 	} 
.................... 	if (new_setup & index_mask) { 
0092:  MOVF   09,W
0094:  ANDLW  10
0096:  MOVWF  00
0098:  CLRF   03
009A:  MOVF   00,W
009C:  IORWF  03,W
009E:  BZ    00A2
.................... 		setup |= index_mask; 
00A0:  BSF    04.4
.................... 	} 
.................... 	if (new_setup & mode_mask) { 
00A2:  MOVF   09,W
00A4:  ANDLW  03
00A6:  MOVWF  00
00A8:  CLRF   03
00AA:  MOVF   00,W
00AC:  IORWF  03,W
00AE:  BZ    00E8
.................... 		switch (new_setup & mode_mask) { 
00B0:  MOVF   09,W
00B2:  ANDLW  03
00B4:  MOVWF  00
00B6:  CLRF   03
00B8:  MOVF   03,W
00BA:  BNZ   00C2
00BC:  MOVLW  01
00BE:  SUBWF  00,W
00C0:  BZ    00D8
00C2:  MOVF   03,W
00C4:  BNZ   00CC
00C6:  MOVLW  02
00C8:  SUBWF  00,W
00CA:  BZ    00DC
00CC:  MOVF   03,W
00CE:  BNZ   00D6
00D0:  MOVLW  03
00D2:  SUBWF  00,W
00D4:  BZ    00E0
00D6:  BRA    00E6
.................... 		case quatrature_mode: 
.................... 			setup |= quatrature_mode; 
00D8:  BSF    04.0
.................... 			break; 
00DA:  BRA    00E8
.................... 		case step_direction_mode: 
.................... 			setup |= step_direction_mode; 
00DC:  BSF    04.1
.................... 			break; 
00DE:  BRA    00E8
.................... 		case brushless_dc_mode: 
.................... 			setup |= brushless_dc_mode; 
00E0:  MOVLW  03
00E2:  IORWF  04,F
.................... 			break; 
00E4:  BRA    00E8
.................... 		default: 
.................... 			break; 
00E6:  BRA    00E8
.................... 		} 
.................... 	} 
.................... 	if (new_setup & resolution_mask) { 
00E8:  MOVF   09,W
00EA:  ANDLW  0C
00EC:  MOVWF  00
00EE:  CLRF   03
00F0:  MOVF   00,W
00F2:  IORWF  03,W
00F4:  BZ    012E
.................... 		switch (new_setup & resolution_mask) { 
00F6:  MOVF   09,W
00F8:  ANDLW  0C
00FA:  MOVWF  00
00FC:  CLRF   03
00FE:  MOVF   03,W
0100:  BNZ   0108
0102:  MOVLW  04
0104:  SUBWF  00,W
0106:  BZ    011E
0108:  MOVF   03,W
010A:  BNZ   0112
010C:  MOVLW  08
010E:  SUBWF  00,W
0110:  BZ    0122
0112:  MOVF   03,W
0114:  BNZ   011C
0116:  MOVLW  0C
0118:  SUBWF  00,W
011A:  BZ    0126
011C:  BRA    012C
.................... 		case _9_bit_resolution: 
.................... 			setup |= _9_bit_resolution; 
011E:  BSF    04.2
.................... 			break; 
0120:  BRA    012E
.................... 		case _8_bit_resolution: 
.................... 			setup |= _8_bit_resolution; 
0122:  BSF    04.3
.................... 			break; 
0124:  BRA    012E
.................... 		case _7_bit_resolution: 
.................... 			setup |= _7_bit_resolution; 
0126:  MOVLW  0C
0128:  IORWF  04,F
.................... 			break; 
012A:  BRA    012E
.................... 		default: 
.................... 			break; 
012C:  BRA    012E
.................... 		} 
.................... 	} 
.................... 	if (zero_mark && zero_mark < 1024) { 
012E:  MOVF   0B,F
0130:  BZ    0158
.................... 		setup |= (long) zero_mark << 5; 
0132:  CLRF   0D
0134:  RLCF   0B,W
0136:  MOVWF  02
0138:  RLCF   0D,W
013A:  MOVWF  03
013C:  RLCF   02,F
013E:  RLCF   03,F
0140:  RLCF   02,F
0142:  RLCF   03,F
0144:  RLCF   02,F
0146:  RLCF   03,F
0148:  RLCF   02,F
014A:  RLCF   03,F
014C:  MOVLW  E0
014E:  ANDWF  02,F
0150:  MOVF   02,W
0152:  IORWF  04,F
0154:  MOVF   03,W
0156:  IORWF  05,F
.................... 	} 
.................... 	output_high(DO_PIN); 
0158:  BCF    F94.5
015A:  BSF    F8B.5
.................... 	delay_us(2); 
015C:  MOVLW  09
015E:  MOVWF  00
0160:  DECFSZ 00,F
0162:  BRA    0160
0164:  BRA    0166
.................... 	output_high(SLAVE_SELECT); 
0166:  BCF    F92.5
0168:  BSF    F89.5
.................... 	delay_us(2); 
016A:  MOVLW  09
016C:  MOVWF  00
016E:  DECFSZ 00,F
0170:  BRA    016E
0172:  BRA    0174
.................... 	spi_xfer(setup); 
0174:  MOVFF  05,0D
0178:  MOVFF  04,0C
017C:  MOVLW  10
017E:  MOVWF  0E
0180:  RCALL  0038
.................... } 
0182:  GOTO   039E (RETURN)
....................  
.................... void clear_bus(void) { 
.................... 	output_low(SLAVE_SELECT); 
.................... 	output_low(CLK_PIN); 
.................... 	output_low(DO_PIN); 
.................... 	output_low(DI_PIN); 
.................... } 
....................  
.................... #endif /* AS5040_H_ */ 
....................  
....................  
.................... static long leitura; 
.................... static int zero; 
.................... //static long periodo, aux; 
....................  
.................... //#INT_CCP1 
.................... //void isr_ccp1(void) { 
.................... //	clear_interrupt(INT_CCP1); 
.................... //	periodo = CCP_1 - aux; 
.................... //	aux = CCP_1; 
.................... //	CCP_1 = 0; 
.................... //} 
....................  
.................... void main(void) { 
*
0348:  CLRF   FF8
034A:  BCF    FD0.7
034C:  CLRF   FEA
034E:  CLRF   FE9
0350:  BSF    FB8.3
0352:  MOVLW  1A
0354:  MOVWF  FAF
0356:  MOVLW  06
0358:  MOVWF  FB0
035A:  MOVLW  A6
035C:  MOVWF  FAC
035E:  MOVLW  90
0360:  MOVWF  FAB
0362:  BSF    F94.4
0364:  BCF    F94.5
0366:  BCF    F94.3
0368:  BCF    F8B.3
036A:  MOVLW  00
036C:  MOVWF  F7E
036E:  BCF    FC1.4
0370:  BCF    FC1.5
0372:  MOVF   F7F,W
0374:  ANDLW  E0
0376:  MOVWF  F7F
0378:  BCF    F79.5
037A:  BCF    F79.4
037C:  CLRF   F7A
037E:  CLRF   F7B
0380:  CLRF   04
0382:  CLRF   05
0384:  CLRF   06
0386:  CLRF   07
0388:  CLRF   08
.................... 	delay_ms(100); 
038A:  MOVLW  64
038C:  MOVWF  0A
038E:  RCALL  0010
.................... //	output_low(SLAVE_SELECT); 
.................... //	setup_ccp1(CCP_CAPTURE_RE); 
.................... //	setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
.................... //	enable_interrupts(INT_CCP1); 
.................... //	enable_interrupts(GLOBAL); 
.................... 	zero = 0; 
0390:  CLRF   08
.................... //	clear_bus(); 
.................... //	delay_ms(100); 
.................... 	setup_encoder(clockwise | _7_bit_resolution | step_direction_mode, zero); 
0392:  CLRF   0A
0394:  MOVLW  0E
0396:  MOVWF  09
0398:  MOVFF  08,0B
039C:  BRA    0080
.................... //	clear_bus(); 
.................... //	printf("\fProg: 7 bits zero %d", zero); 
.................... //	delay_ms(1000); 
.................... 	while (TRUE) { 
.................... 		output_low(SLAVE_SELECT); 
039E:  BCF    F92.5
03A0:  BCF    F89.5
.................... 		leitura = spi_xfer(0); 
03A2:  CLRF   0D
03A4:  CLRF   0C
03A6:  MOVLW  10
03A8:  MOVWF  0E
03AA:  RCALL  0038
03AC:  MOVF   01,W
03AE:  MOVFF  02,07
03B2:  MOVFF  01,06
.................... 		output_high(SLAVE_SELECT); 
03B6:  BCF    F92.5
03B8:  BSF    F89.5
.................... 		printf("\f%Lu  -  %d", leitura >> 6, (int) (leitura & 0x0006) >> 1); 
03BA:  RRCF   07,W
03BC:  MOVWF  0A
03BE:  RRCF   06,W
03C0:  MOVWF  09
03C2:  RRCF   0A,F
03C4:  RRCF   09,F
03C6:  RRCF   0A,F
03C8:  RRCF   09,F
03CA:  RRCF   0A,F
03CC:  RRCF   09,F
03CE:  RRCF   0A,F
03D0:  RRCF   09,F
03D2:  RRCF   0A,F
03D4:  RRCF   09,F
03D6:  MOVLW  03
03D8:  ANDWF  0A,F
03DA:  MOVF   06,W
03DC:  ANDLW  06
03DE:  MOVWF  00
03E0:  CLRF   03
03E2:  MOVF   00,W
03E4:  BCF    FD8.0
03E6:  RRCF   00,W
03E8:  MOVWF  0B
03EA:  MOVLW  0C
03EC:  BTFSS  F9E.4
03EE:  BRA    03EC
03F0:  MOVWF  FAD
03F2:  MOVLW  10
03F4:  MOVWF  FE9
03F6:  MOVFF  0A,0D
03FA:  MOVFF  09,0C
03FE:  BRA    0186
0400:  MOVLW  08
0402:  MOVWF  FF6
0404:  MOVLW  00
0406:  MOVWF  FF7
0408:  MOVLW  05
040A:  MOVWF  0C
040C:  BRA    022C
040E:  MOVFF  0B,0C
0412:  MOVLW  1F
0414:  MOVWF  0D
0416:  BRA    0276
.................... //		printf("\nPer: %Lu", periodo); 
.................... 		delay_ms(500); 
0418:  MOVLW  02
041A:  MOVWF  09
041C:  MOVLW  FA
041E:  MOVWF  0A
0420:  RCALL  0010
0422:  DECFSZ 09,F
0424:  BRA    041C
.................... //		delay_us(2); 
.................... //		delay_cycles(8); 
.................... //		output_toggle(PIN_C7); 
.................... 	} 
0426:  BRA    039E
.................... } 
0428:  SLEEP 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV18 NOWDT WDT32768
   Word  3: 8F00   CCP2C1 PBADEN LPT1OSC HFOFST MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
